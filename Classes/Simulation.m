classdef Simulation
    properties
        scale
        totalCounts
        totalEnergy
        intTrans
        
    end
    
    methods
        function obj = Simulation(scale)
            
            if nargin == 0
                obj.scale = 1;
            else
                obj.scale = scale;
            end
        end

    end
    
    methods(Static)
        
        function [sampledstar] = addStar(R,pixSamp,scale,wavelength,spectrum,rv,persistence)
            
            
            % Define wavelength step (input in microns, output in microns) using maximum resolving power (R),
            % pixSamp, and scale factor
            dlam = 1/R/pixSamp;
            step = dlam/scale;
            interplambda = wavelength(1):step:wavelength(end);
            interpflux = interp1(wavelength, spectrum, interplambda,'linear');
            dsWavelength = Star.dopplerShift(interplambda,rv); %Shift Wavelength and assign DsWavelength
            
            if persistence == 0
                counts = Star.energy2Counts(dsWavelength,interpflux);
            else
                counts = Star.energy2Counts(dsWavelength,persistence*interpflux);
                
            end
            sampledstar = [dsWavelength;counts]';
            
                
            end
        
        
        function [combinedSpectra] = CombineSpectra(spectrum1,spectrum2)
           
            
            % interpolate spectrum 2 onto spectrum 1
            interpFlux = interp1(spectrum2(:,1),spectrum2(:,2), spectrum1(:,1),'linear',0);
            
            combinedSpectra(:,1) = spectrum1(:,1);
            combinedSpectra(:,2) = spectrum1(:,2)+interpFlux;
            
%             figure
%             plot(spectrum1(:,1),spectrum1(:,2))
%             hold on
%             plot(spectrum2(:,1),spectrum2(:,2))
%             set(gca,'yscale','log')
        end
        
        
        
        function [counts] = addCollectingArea(countsPerArea,dTel,blockFrac)
            
            collecting_area = pi*(dTel/2)^2 - pi*(blockFrac*dTel/2)^2;
            counts = countsPerArea * collecting_area;
            
        end
        
        function [y_grid] = resampleToGrid(x,y,x_grid)
            % this function cuts a new x vector and the max of the original and
            % extrapolates the short end of the new x vector to the short end of the
            % original x vector. The new y vector for use is generated by interpolating the
            % new_x,new_y onto the original x vector.
            
            extrap_scalar = min(y);
            ub = min(x(end,1),x_grid(end,1));
            ind = find(x<=ub,1,'last');
            x_safe = x(1:ind);
            y_safe = y(1:ind);
            
            y_grid = interp1(x_safe(:,1),y_safe(:,1),x_grid,'linear',extrap_scalar);
            
        end
        
        function [addtell] = addAtmosphere(wavelength,counts, telluric, skyback)
            
            skygrid = Simulation.resampleToGrid(skyback(:,1),skyback(:,2),wavelength);
            
            addsky = counts;% + skygrid;
            
            tellgrid = Simulation.resampleToGrid(telluric(:,1),telluric(:,2),wavelength);
            
            addtell = addsky.*tellgrid;
        end
        
        function [starThroughput,comTput] = combineImagerThroughput(star_components)
            comTput{1,1} = star_components(1).finalThroughput;
            comTput{2,1} = star_components(1).name;
            
            for ii = 2:size(star_components,2) %loop over cellarry size (i.e. surfaces)
                [comTput{1,ii}(:,1),comTput{1,ii}(:,2)] = Instrument.multiply_curves...
                    (comTput{1,ii-1}(:,1),comTput{1,ii-1}(:,2),...
                    star_components(ii).finalThroughput(:,1),star_components(ii).finalThroughput(:,2));
                
                comTput{2,ii} = star_components(ii).name; % add the object name to the cell array for progression plots
            end
            
            starThroughput = comTput{1,end};
        end
        
        function [output] = Xdisperse(inputSpectrum,nOrders,waveCoeff)
            
            
            temp{1} = repmat(inputSpectrum(:,1)',nOrders,1)';
            temp{2} = repmat(inputSpectrum(:,2)',nOrders,1)';
            
            
            [outputWavelength, outputOrders] = Simulation.trimOrders(temp{1}, temp{2}, waveCoeff,nOrders);
            
            
            output{1} = outputWavelength;
            output{2} = outputOrders;
            
        end
        
        function [OutWavelength, OutSpectrum] = trimOrders(wavelength,spectrum,wave_coeff,nOrders)
            
            ord = size(spectrum, 2); % what is the largert order (39)
            buffer_edge = 25; %set detector edge (buffered by 5mm)
            
            ind_lim1 = find(wavelength(:,ord) <= polyval(wave_coeff(ord,:,1),-buffer_edge),1,'last');
            ind_lim2 = find(wavelength(:,ord) >= polyval(wave_coeff(ord,:,1), buffer_edge),1,'first');
            max_length = (ind_lim2-ind_lim1); % find the length of the largest order with buffer
            
            for ii = 1:nOrders
                
                ind1 = find(wavelength(:,ii) <= polyval(wave_coeff(ii,:,1), -buffer_edge),1,'last');
                ind2 = max_length + ind1; % ind2 is forced to match largest order size
                %                 disp(ind2-ind1) %check all orders are the same size
                OutWavelength(:,ii) = wavelength(ind1:ind2,ii);
                OutSpectrum(:,ii) = spectrum(ind1:ind2,ii);
                %                 disp(ii)
            end
            
        end
        
        function [output] = addSpecThroughput(spectral_cell,finalThroughput,nOrders)
            
            for ii = 1:nOrders
                new_y = Simulation.resampleToGrid(finalThroughput{2}(:,ii)*1e-3,finalThroughput{1}(:,ii),spectral_cell{1}(:,ii));
                output{1}(:,ii) = spectral_cell{1}(:,ii);
                output{2}(:,ii) = new_y .* spectral_cell{2}(:,ii);
                
            end
            
        end
        
        function [PSF,center] = MakePSF(scale,pix_samp,vert_samp)
            
            % dispersion direction
            fwhm = pix_samp*scale;
            sigmax=fwhm/(2*sqrt(2*log(2)));
            
            % cross dispersion direction
            fwhmy = vert_samp*scale;
            sigmay=fwhmy/(2*sqrt(2*log(2)));
            
            % trim according to bigger dimension
            Nsigmas = 9;
            val = Nsigmas * sigmay;
            %
            
            %             clip = 3/(2*sqrt(2*log(2)));
            %             val = 25*clip;
            
%             oddGrid=2*round(val/2)-1; % not super important but lets go with an odd grid size every time
            oddGrid = 11*2+1;
            [MatX,MatY]=meshgrid(1:1:oddGrid,1:1:oddGrid); % make the mesh grid
            
            center = [round(size(MatX,2)/2),round(size(MatY,1)/2)]; % center x and y in the (likely) non-integer center of grid ;
            % this is the most important line - the center of the PSF must fall in a pixel center
            % subtract the center in the x direction from the full convolution to get a "central" conv. result
            %....maybe not certain.
            
            PSF=circ_gauss(MatX,MatY,[sigmax,sigmay],center);
            
            
        end
        
        function [APSF] = makeAbPsf(wfe,pixSamp,scale)
            
            grid= 51;
            pad = round((((fliplr(scale*pixSamp)-3)/3)+0.5)*grid);
           
            %Zernike phase map
            W = 0; %
            for z = 1:length(wfe)
                Z = ZernikeCalc(z,1,grid); % use ZernikeCalc to produce normalized zernike surface
                Z = padarray(Z,pad);% increase padding on output;
                Z = Z./(max(max(Z)));
                Ab = wfe(z)*Z;
                W = W+Ab;
            end
            
            N = size(W);% variable 7/25/17 Sampling points
            dl = 1;%L/N; %Pupil plane grid spacing (meters)
            
            [xgrid,ygrid] = meshgrid((-N(2)/2+0.5:N(2)/2-0.5),(-N(1)/2+0.5:N(1)/2-0.5));
            
            circle = circ(xgrid,ygrid,grid);%outer circle
            
            gauss=circ_gauss(xgrid,ygrid,[grid/8 grid/8]*sqrt(2),[0,0]);
            
            gauss = gauss./(max(max(gauss)));
            pupil = circle.*gauss;
            
            Pupil = pupil.*exp(1i*W); %Complex Pupil plane with phase term
            
            %Propogate the pupil plane to focal plane (electric fields) at
            %all wavelengths
            
            % b = sum(abs(Pupil).^2,1);
            % startPoints = [0.35 size(W,2)/2 pixSamp(2)*scale];
            % gaussEqn = 'a*exp(-((x-b)/(sqrt(2)*c))^2)';
            % f2 = fit((1:length(b))',b',gaussEqn,'Start', startPoints,'Lower', [0, 0, 0]);
            % fprintf('pupil sigma %.3f, %.3f\n',f2.c,grid/8)
            
            PSF = ft2(Pupil,dl);
            
            APSF = abs(PSF).^2;
            keep = round(grid/4);
            APSF = APSF(0.5+N(1)/2-keep:N(1)/2+0.5+keep,0.5+N(2)/2-keep:N(2)/2+0.5+keep);
            
            APSF = APSF./(sum(sum(APSF)));
        end

        function [trim, wavelength] = ConvolveOrder(wavelength,spectrum,wave_coeff,wfe,scale,ordernum)
            
            % trim each order beyond the edge of the detector
            
            ind1 = find(wavelength <= polyval(wave_coeff,-22.48),1,'last');
            ind2 = find(wavelength >= polyval(wave_coeff, 22.48),1,'first');
            
            wavelength = wavelength(ind1:ind2)';
            spectrum = spectrum(ind1:ind2)';
            
            % sampled at the high end. 3 pixels at red, smooth function to
            % 6 pixels at blue. this is pretty unique to iLocater's design
            
            horSamp = linspace(3,3,length(wavelength));
            vertSamp = median(horSamp);
            
            scaleH = interp1([3 3.0561 3.14 3.559 4 5 6]/3,[0.0001 0.1 1/3 0.5833 0.87 1.333 1.75],horSamp/3,'linear','extrap');
            scaleV = interp1([3 3.0561 3.14 3.559 4 5 6]/3,[0.0001 0.1 1/3 0.5833 0.87 1.333 1.75],vertSamp/3,'linear','extrap');
            

            %%% Aberration Map %%% 
%             cdisp_wfe = linspace(1/16,0,36/2);
%             cdisp_wfe = [cdisp_wfe fliplr(cdisp_wfe)];
%             
%             disp_wfe = linspace(1/16,0,length(wavelength)/2);
%             disp_wfe = [disp_wfe fliplr(disp_wfe)];
%             if rem(length(wavelength),2) ~= 0
%                 disp_wfe = [disp_wfe disp_wfe(end)];
%             end
%             
%             assert(length(disp_wfe) == length(wavelength))
   
            
            % Custom convolution
            
            % Do the first loop iteration outside the loop. Need to
            % calculate dim first
            ii = 1;
            wfe(7) = 0;%disp_wfe(ii);
            wfe(8) = 0;%cdisp_wfe(ordernum);  
            
            
            %%% Linear scaling from one psf to another %%% 
            % Determine wfe to use. scale it off of wavelength...horSamp(ii) vertSamp 
%             wfeList{ii} = 2*pi*wfe*(0.97/wavelength(ii));
            

            %%% Constant PSF %%% 
            wfeList{ii} = 2*pi*wfe;
            PSF(:,:,1) = Simulation.makeAbPsf(wfeList{ii},0.9*[3 3],scale);
%             PSF(:,:,1) = Simulation.makeAbPsf(wfeList{ii},[horSamp(ii) vertSamp],scale);
            [kernel,~] = Simulation.MakePSF(scale,scaleH(1)*0.9*3,scaleV*0.9*3);
            % broaden the default 3x3 pixel sampling according to the specific sampling needed
            PSF(:,:,1) = conv2(PSF(:,:,1),kernel,'same'); 
            
            
            center = [round(size(PSF,2)/2),round(size(PSF,1)/2)];

            
            % No aberrations
%             [PSF,center] = Simulation.MakePSF(scale,horSamp(ii),vertSamp);
            dim = size(PSF,1);
            rectangle = zeros(dim,length(wavelength)+dim-1);
            rectangle(:,ii:dim-1+ii)=rectangle(:,ii:dim-1+ii)+PSF(:,:,ii).*spectrum(ii);
            
            for ii = 2:length(wavelength)

%                 wfeList{ii} = 2*pi*wfe*(0.97/wavelength(ii));
                wfe(7) =0;%disp_wfe(ii);
                wfeList{ii} = 2*pi*wfe;

                PSF(:,:,ii) = Simulation.makeAbPsf(wfeList{ii},[horSamp(ii) vertSamp],scale);

                PSF(:,:,ii) = Simulation.makeAbPsf(wfeList{ii},0.9*[3 3],scale);
                % PSF(:,:,1) = Simulation.makeAbPsf(wfeList{ii},[horSamp(ii) vertSamp],scale);
                [kernel,~] = Simulation.MakePSF(scale,scaleH(ii)*0.9*3,scaleV*0.9*3);
                % broaden the default 3x3 pixel sampling according to the specific sampling needed
                PSF(:,:,ii) = conv2(PSF(:,:,ii),kernel,'same');
                
                
%                 [PSF,~] = Simulation.MakePSF(scale,horSamp(ii),vertSamp);
                
                %                 Conv1 = conv2(spectrum(ii),PSF,'full');
                
                
                rectangle(:,ii:dim-1+ii)=rectangle(:,ii:dim-1+ii)+PSF(:,:,ii).*spectrum(ii);
                
                
                %                 rectangle(:,ii:dim-1+ii)=rectangle(:,ii:dim-1+ii)+Conv1;
                
                
            end
%             save(['PSFCube_order' num2str(ordernum) '.mat'],'PSF','-mat');
            trim = rectangle(:,center(1):end-(size(PSF,2)-center(1)));
            
        end
        
        function detector = CliptoDetector(order,wavelength,order_coeff,wave_coeff,cheby,p1,specorder)
            
            
            % convert each xypair into a set of 4 verticies for the pixel. Depends on PSF scaling etc..
            % from PSF convolution - know what one square "sample" is in mm. Does that still work after convolution?
            %% XY location pair for each point on wavelength vector
            xy_pair = zeros([size(order),2]);
            
            [~,beta] = max(order);
            center = mode(beta);
            
            % Convert lambda to X based on Zemax order fit
            % new x  =  interpolate (lam,x,lam')
            
            %             xy_pair(center,:,1) = interp1( polyval(wave_coeff,((1:0.1:4096)-2048)/100)  , ((1:0.1:4096)-2048)/100   ,wavelength,'linear','extrap');
            
            %             xy_pair(center,:,1) = interp1( polyval(wave_coeff,-25.48:0.00001:25.48), (-25.48:0.00001:25.48) ,wavelength,'linear','extrap');
            
            % Chebyshev 2D polynomial wavelength interpolation.
            specorder = 40-specorder;
            if cheby == 1
                Inverse =1;
                nx = 7;
                nm = 7;
                ntotal = 39;
                npix = 4096;
                order0 = 113;
                finex=-25.48:0.01:25.48;
                fineorders = specorder*ones(size(finex)); % what spectral order are we at?
                finechebs = Calculate_chebs(finex, fineorders+order0,Inverse,order0,ntotal,npix,nx,nm); 
                finewavelengths = JointFitFunc(p1,finechebs,fineorders+order0,nx,nm); 
                
                xy_pair(center,:,1) = interp1( finewavelengths,finex,wavelength,'linear','extrap');
                
            else
                % using 4th order, 1D polynomial needs interpolation. Inversion
                % is not possible.
                xy_pair(center,:,1) = interp1( polyval(wave_coeff,-25.48:0.00001:25.48), (-25.48:0.00001:25.48) ,wavelength,'linear','extrap');
            end
            
            % Inverting the 2nd order 1D polynomial
            %             a = wave_coeff(1);
            %             b = wave_coeff(2);
            %             c = wave_coeff(3);
            %
            %             xy_pair(center,:,1) = (-b + sqrt(b^2-4*a*(c-wavelength)))/(2*a);
            
            
            % fprintf('Counts before detector: %.5f', sum(sum(order)))
            %% This makes the order flat
            %              test = xy_pair(center,1,1).*ones(1,size(order,2));
            %              xy_pair(center,:,2) = polyval(order_coeff,test);
            
            
            xy_pair(center,:,2) = polyval(order_coeff,xy_pair(center,:,1));
            
            % multiply by 100 to convert x,y mm to pixels then move 0,0 from center to bottom left
            xy_pair =xy_pair*100+4096/2;
            
            delta_w = diff(wavelength)/2;
            delta_w = [delta_w delta_w(end)];
            
            edges_w = [wavelength(1)-delta_w(1) wavelength+delta_w];
            if cheby ==1
                edges_x = interp1( finewavelengths, finex ,edges_w,'linear','extrap');
            else
                edges_x = interp1( polyval(wave_coeff,-25.48:0.00001:25.48), (-25.48:0.00001:25.48) ,edges_w,'linear','extrap');
            end
            %             edges_x = (-b + sqrt(b^2-4*a*(c-edges_w)))/(2*a);
            edges_x = edges_x*100+4096/2;
            
            
            %             offset = xy_pair(center,2:size(xy_pair,2),1)-xy_pair(center,1:size(xy_pair,2)-1,1);
            %             offset = [offset offset(end)];
            
            yoffset = [center-1:-1:1 0 -(1:size(order,1)-center)];
            
            detector = zeros(4096+4,4096+4); % 4096x4096 + 2 extra for padding
            
            %%% XY center pairs for entire order
            
            % xy_pair(vertical scalar index, horizontal vector of length, x and y)
            
            for jj = 1:size(xy_pair,2)
                for ii = [1:center-1 center+1:size(order,1)]
                    xy_pair(ii,jj,1) = xy_pair(center,jj,1);
                    %                     xy_pair(ii,jj,2) = xy_pair(center,jj,2)+ yoffset(ii)*offset(1);
                    xy_pair(ii,jj,2) = xy_pair(center,jj,2)+ yoffset(ii)*mean(diff(edges_x));
                    
                end
            end
            
            
            for ii = [1:center-1 center center+1:size(order,1)]
                
                for jj =1:size(xy_pair,2)
                    %                     xlist{ii}{jj} = xy_pair(ii,jj,1) + [-1 1 1 -1 -1]*offset(jj)/2 ; %x starting at top left, clockwise
                    %                     ylist{ii}{jj} = xy_pair(ii,jj,2) + [1 1 -1 -1  1]*offset(1)/2; % y ***extra final point to draw box
                    xlist{ii}{jj} = [edges_x(jj) edges_x(jj+1) edges_x(jj+1) edges_x(jj) edges_x(jj)];
                    ylist{ii}{jj} = xy_pair(ii,jj,2) + [1 1 -1 -1  1]*mean(diff(edges_x))/2; % y ***extra final point to draw box
                    
                    % +1 to the x and y list to account for a 1 cell padd
                    % to remove edge clipping errors.
                    [area,ind]=polyfillaa(2+xlist{ii}{jj},2+ylist{ii}{jj},4+4096, 4+4096);
                    ind = ind+1;
                    detector(ind) = detector(ind)+order(ii,jj).*area./sum(area);
                    clear ind area
                end
                
            end
            
            
            detector = detector(3:end-2,3:end-2); % remove padding
            detector = detector';
            
            
            
            % Plotting - be careful with this
            %             figure(100);
            %             hold on
            %
            %             for jj = 1:200%size(order,2)
            %
            %                 for ii = [1:center-1 center center+1:size(order,1)]
            %
            %
            % %                     plot(xy_pair(:,jj,1),xy_pair(:,jj,2),'.k')
            %
            %                     plot(xlist{ii}{jj},ylist{ii}{jj},'-','color',colors{rem(jj,length(colors)-1)+1})
            %
            %
            %
            %                 end
            %             end
            
            
        end
        
        function WriteFits(filename,image,headerinfo)
            
            import matlab.io.*
            DataType = 'single';
            % create fits file
            fptr = fits.createFile(filename);
            
            % Create Image extension
            fits.createImg(fptr,DataType,size(image));
            
            % Write image to file
            fits.writeImg(fptr,image);
            
            % Write additional keywords
            for ii = 1:size(headerinfo,1)
                fits.writeKey(fptr,headerinfo{ii,1},headerinfo{ii,2},headerinfo{ii,3});
                
            end
            % close file
            fits.closeFile(fptr);
            
        end
        
        function [trimWave,trimCounts] = trimToBand(wavelength,counts,bandPass)
            
            ind = wavelength<=bandPass(2) & wavelength>=bandPass(1);
            
            trimWave = wavelength(ind);
            trimCounts = counts(ind);
            
            
        end
        
        function [SR_interp] = calculateStrehlRatio(aoType,seeing,counts,zenith)
            
            current_path = pwd;
            if current_path(1:7) == 'Volumes'
                
                strehl_dir = 'Volumes/Software/Simulator/RefFiles/AO/';
            else
                
                strehl_dir = [current_path(1:2) '\Simulator\RefFiles\AO\'];
            end
            
            
            refS=[0.6,0.8,1];
            [~,indmatch] = min(abs(refS-seeing));
            
            if strcmp(aoType,'FLAO') == 1
                file = 'FLAO_Strehl.csv';
                refSeeing = 1;
            else
                if indmatch == 1
                    file = 'SOUL_Strehl_06_vib.csv';
                    refSeeing = refS(indmatch);
                elseif indmatch == 2
                    file = 'SOUL_Strehl_08_vib.csv';
                    refSeeing = refS(indmatch);
                elseif indmatch == 3
                    file = 'SOUL_Strehl_1_vib.csv';
                    refSeeing = refS(indmatch);
                end
            end
            
            filename = strcat(strehl_dir,file); % found the closest reference filename for this AO system
            
            %--------------------------------------------------------------------------%
            %--------------------------------------------------------------------------%
            %Description: Read in reference WFS file from LBT ao group
            
            delimiter = ',';
            startRow = 2;
            endRow = inf;
            formatSpec = '%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%[^\n\r]';
            
            % Open the text file.
            fileID = fopen(filename,'r');
            dataArray = textscan(fileID, formatSpec, endRow(1)-startRow(1)+1, 'Delimiter', delimiter, 'HeaderLines', startRow(1)-1, 'ReturnOnError', false);
            for block=2:length(startRow)
                frewind(fileID);
                dataArrayBlock = textscan(fileID, formatSpec, endRow(block)-startRow(block)+1, 'Delimiter', delimiter, 'HeaderLines', startRow(block)-1, 'ReturnOnError', false);
                for col=1:length(dataArray)
                    dataArray{col} = [dataArray{col};dataArrayBlock{col}];
                end
            end
            % Close the text file.
            fclose(fileID);
            
            % Allocate imported array to column variable names
            MagR = dataArray{:, 1}; %r amgnitude
            SRR = dataArray{:, 2}; %R band Strehl ratio
            SRI = dataArray{:, 3}; %I band Strehl ratio
            SRY = dataArray{:, 4}; %Y band Strehl ratio
            SRJ = dataArray{:, 5}; %J band Strehl ratio
            SRH = dataArray{:, 6}; %H band Strehl ratio
            SRK = dataArray{:, 7}; %K band Strehl ratio
            SRL = dataArray{:, 8}; %L band Strehl ratio
            SRM = dataArray{:, 9}; %M band Strehl ratio
            Totalnm = dataArray{:, 10}; % total nm (not sure what this is)
            bin = dataArray{:, 11}; % WFS binning mode
            modamplD = dataArray{:, 12}; % not sure what this is I/D are units
            fsHz = dataArray{:, 13}; % frame rate in Hz
            fluxphfr = dataArray{:, 14}; % photons/frame
            fluxphfrsa = dataArray{:, 15}; % photons/frame/sub aperture
            fluxphfrpix = dataArray{:, 16}; % photons/frame/pixel
            modes1 = dataArray{:, 17}; % number of AO modes
            Photmodes = dataArray{:, 18}; %photons /mode
            gain = dataArray{:, 19}; % gain
            TTgain = dataArray{:, 20}; % tip/tilt gain
            
            %--------------------------------------------------------------------------%
            %--------------------------------------------------------------------------%
            %Description: Calcaulte the Strehl ratio based on incident photons to WFS
            %Inputs: photons/second/subaperture. The # of subapertures depends on the binning mode.
            %The FLAO system has 30 max across the pupil which is reduced by binning.
            
            %******* I believe the AO group sent data which double counted
            %the binning effect of their detector. I've checked this using
            %their own numbers send by Guido and rechecked again 3/6/18.
            %1.99E10 ph/s/m^2 is the 0th order NGS (close to G2). Using
            %this and 0.32 (0.29 in paper) throughput for atmosphere, LBT,
            %WFS, the total number of photons calculated is more than the
            %LBTI reference files by a factor of the binning squared. Thus
            %to remove the error, we need to multiply the refernce file
            %numbers by the binning squared. Ultimately we get the same
            %strehl ratio for a G2 star at all the rights magnitudes. I
            %never got around to bringing this up with them...
            
            %9/6/18 edit. The above phrasing is a bit weird. To clarify the
            %rows with 1 binning are fine. The flux is given in
            %photons/frame/subaperture. To compute the photons/frame we
            %multiply by (subapertures/binning)^2*pi. The problem is I
            %believe the original photons/frame/subaperture value already
            %removed the effect of binning i.e reduced the photons per
            %frame back down based on 30 subapertures. This is based on my
            %simulated total photons vs. values in their sheet being off by
            %the binning^2. The original file reduced the photons by the
            %binning again with the above area factor which gives the wrong
            %number of photons/frame. I undo this by multiplying by the
            %binning^2. At the end of the day I get the correct Strehl vs R
            %mag so this was just a way of sorting the total photons out.
            
            phfr= (fluxphfr(:,1).*(bin.^2)); %remove double binning effect by multiplying binning factor squared
            phs = phfr(:,1).*fsHz; %photons/second
            
            % phfrpix_binned = fluxphfrpix(:,1).*(bin.^2);
            % phfrpix = fluxphfrpix(:,1);
            % phfrpixppl = phfrpix/4;
            
            high = max(phs);
            low  = 0;
            num = 1000000;
            xq = linspace(low,high,num);
            vqy = interp1(phs,SRY,xq,'pchip');
            vqj = interp1(phs,SRJ,xq,'pchip');
            vqr = interp1(phs,SRR,xq,'pchip');
            vqi = interp1(phs,SRI,xq,'pchip');
            vqh = interp1(phs,SRH,xq,'pchip');
            vqk = interp1(phs,SRK,xq,'pchip');
            vql = interp1(phs,SRL,xq,'pchip');
            vqm = interp1(phs,SRM,xq,'pchip');
            
            if counts > high
                StrehlY = max(vqy);
                StrehlJ = max(vqj);
                StrehlR = max(vqr);
                StrehlI = max(vqi);
                StrehlH = max(vqh);
                StrehlK = max(vqk);
                StrehlL = max(vql);
                StrehlM = max(vqm);
                ind = 1;
            else
                ind = find(xq>counts,1,'first');
                StrehlY = vqy(ind);
                StrehlJ = vqj(ind);
                StrehlR = vqr(ind);
                StrehlI = vqi(ind);
                StrehlH = vqh(ind);
                StrehlK = vqk(ind);
                StrehlL = vql(ind);
                StrehlM = vqm(ind);
            end
            
            if strcmp(aoType,'FLAO') == 1
                fs = [1000.1 1000.01 1000.001 1000.0001 200 100];
                bin = [1.0001 1.001 2 4 4.0001 4.001 4.01];
            else
                fs = [1500.1 1500.01 1250 750 300 100];
                bin = [1.0001 1.001 1.01 2 3 4];
            end
            
            ref_SR = [StrehlR,StrehlI,StrehlY,StrehlJ,StrehlH,StrehlK,StrehlL,StrehlM]./100; %Strehl ratio samples points units : 0-1;
            
            %--------------------------------------------------------------------------%
            %--------------------------------------------------------------------------%
            %Description: Rescale the Strehl ratio as a function of seeing
            %Input: Strehl ratio from 0-1, seeing in arcseconds
            %Documentation: assume the SR scales as exp(-sigma^2), and sigma^2
            %scales as is (1/r0)5/3. (found in Andreas Quirrenbach citation...).
            % seeing angle ~ lambda/r0 so r0 ~ 1/seeing for a given wavelength
            % r1/r2 = seeing1/seeing2 at a lambda
            
            SR = exp((seeing/refSeeing)^(5/3).*log(ref_SR)); % rescale the Strehl ratio based on seeing ;
            
            %--------------------------------------------------------------------------%
            %--------------------------------------------------------------------------%
            %Description: Rescale the Strehl ratio as a function of zenith angle
            %Input: Strehl ratio from 0-1, zenith angle in radians
            %Documentation:
            %Roddier A0 Textbook and Devaney 2007
            %SR = exp(-sigma^2)
            %r0 ~ cos(z)^3/5 scale factor for seeing angle (from Francois Roddier AO book)
            %The intention is to rescale the freid parameter which is buried in a
            %constant exp -(A/ro)^-5/3 or exp(-B). ro scales as cos(z)^3/5 then the constant (B) scales
            %as (cos(z)^3/5)^-5/3 which is just sec(z)
            %SR(zenith) = exp(-alog(SR(0)) * airmass(zenith)) = exp(-alog(SR(0)) * (seeing(zenith)/seeing(0))^(5./3.))
            %where
            %seeing(zenith) = seeing(0)*airmass(zenith)^(3./5.)
            %airmass(zenith) = 1./cos(zenith/180.*!pi)
            %--------------------------------------------------------------------------%
            
            B = abs(log(SR));% constant
            scale = sec(zenith);%.^(3/5).^(5/3); % also known as sec(z)
            SR_z = exp(-B.*scale);% rescale the strehl ratio and multiply by 100 to get back to % Strehl
            
            %--------------------------------------------------------------------------%
            %--------------------------------------------------------------------------%
            %Description: Interpolate the Strehl Ratio samples over wavlength band using
            % pchip method.
            %Input: Strehl ratio from 0-1 and wavelength samples in microns
            %Documentation:
            % Interpolation method is quick and easy for a smooth SR in ilocater band.
            % This could be replaced in the future by analytic scaling (fried parameter
            % ,r0,scales as lambda^(6/5), so a fitting method could be
            % used as well
            
            Strehl = SR_z;
            step = 1E-4; % sampling in microns
            Band_centers = [0.640,0.750,1.020,1.250,1.650,2.200,3.805,4.781];% from SOUL Excel document header information
            xq = Band_centers(1,1):step:Band_centers(1,end); %generate highly sampled wavelength vector
            SR = interp1(Band_centers, Strehl,xq,'pchip');
            SR_interp(:,1) = xq;
            SR_interp(:,2) = SR;
            
        end

        function [] = ProgressionPlot(compTput)
            handle =[];
            
            % Custom color lists, yo
            %science = get(groot,'DefaultAxesColorOrder');
            
            science = viridis(8);
            for ii = 1:length(science)
                colors{ii}=science(ii,:);
            end
            
%             %% Custom color lists, yo
%             d = get(groot,'DefaultAxesColorOrder');
%             for ii = 1:7
%                 colors{ii}=d(ii,:);
%             end
%             
%             colors{8}= [0.175 0.175 0.175];
%             colors{9}= colors{2};
%             colors{10}= colors{3};
%             colors{11} =[0 0.3 0];
%             clear d
            
            labels = [];
            for ii = 1:size(compTput,2)
                temp{1} = compTput{2,ii};
                labels = [labels;temp];
            end
            
            m = size(compTput,2);
            
            if strcmp(labels(end),'Spectrograph')
                
                n = m - 1;
            else
                n = m;
            end
            
            
            figure('units','normalized','outerposition',[0 0 0.5 1])
            hold on

            for ii = 1:n
                h{ii} = plot(compTput{1,ii}(:,1),compTput{1,ii}(:,2),'-','linewidth',2,'Markersize',8,'Color',colors{ii});
                handle = [handle h{ii}];
            end
            
            if n~= m
            
            for jj = 1:size(compTput{1,m}{1,2},2)
                h{ii+1}=plot(compTput{1,m}{1,1}(:,jj),compTput{1,m}{1,2}(:,jj),'-','linewidth',2,'Color',colors{ii+1},'Markersize',8);
                if jj == 1
                    handle = [handle h{ii+1}];
                end
            end
            
            end
            
            l=legend(handle,labels,'Location','northwest');
            ylim([0 1])
            xlim([800 1600])
            ylabel('Throughput')
            xlabel('Wavelength (nm)')
            l.FontSize = 18;
            l.Box = 'off';
            box on
            grid on
            grid minor
            ax = gca;
            ax.LineWidth = 1.5;
            ax.FontSize = 18;
            
        end
        
        function [frame] = simulateImager(psf,dimensions,pixelpitch,totalCounts)
            %should eventually be the PSF simlaution using fourier transform
            %create the frame based on detector specs
            if isempty(dimensions) == 1
                dimensions = [100,100];
            end
            
            if isempty(pixelpitch) == 1
                pixelpitch = 5e-6;
            end
            
            rows = dimensions(1);
            columns = dimensions(2);
            [MatX,MatY]=meshgrid(1:columns,1:rows); % make the mesh grid
            
            %PSF parameters (gaussian for now)
            sigmax = psf./2.355./pixelpitch; %sigma in pixel units 
            sigmay = sigmax;
            center(1) = round(rows/2);
            center(2) = round(columns/2);
            
            %noiseless frame
            PSF=circ_gauss(MatX,MatY,[sigmax,sigmay],center);
            
            %convolve
            frame = conv2(PSF,totalCounts);
            
        end
        
        
    end
end

function [areas,ret] = polyfillaa(px,py,sx,sy)



% Clip grid to the enclosing box

left = max(floor(min(px)),0);
right = min(floor(max(px)),sx-1);
bottom = max(floor(min(py)),0);
top = min(floor(max(py)),sy-1);
nx=right-left+1;
ny=top-bottom+1;


if nx < 1 || ny < 1
    
    %     disp('clipping missed grid')
    ret = 0;
    areas = 0;
    return
end

%npix is the maximum possible number of clipped polys
npix=nx*ny;

if npix <= 0
    %     disp('clipping missed grid')
    ret = 0;
    areas = 0;
    return
end

ind = 1;

areas = [];%zeros(1,npix);
ret = [];%zeros(1,npix);
%
% figure(1)
% plot([px,px(1)],[py,py(1)],'-k')

for p = 1
    px1 = px;
    py1 = py;
    
    
    for j = bottom(p):top(p)
        for i =left(p):right(p)
            px_out = px1;
            py_out = py1;
            %             polyclip(i,j,px_out,py_out)
            Polygon=[px_out;py_out]';
            unitPixel = [i,i+1,i+1,i;j,j,j+1,j+1]';
            
            clippedPolygon = sutherlandHodgman(Polygon,unitPixel);
            %             figure(1)
            %             hold on
            
            
            if isempty(clippedPolygon) ==1
                continue
                
            end
            %             plot([clippedPolygon(:,1)',clippedPolygon(1,1)],[clippedPolygon(:,2)',clippedPolygon(1,2)],'-o')
            
            
            ret(ind)=i+j*sx;
            
            
            px_out = clippedPolygon(:,1);
            py_out = clippedPolygon(:,2);
            
            
            
            areas(ind) = abs(sum(px_out.* circshift(py_out,-1)-py_out.*circshift(px_out,-1))./2);
            ind = ind+1;
        end
    end
end


zero_ind = find(areas==0);
areas(zero_ind)=[];
ret(zero_ind)=[];

end
function clippedPolygon = sutherlandHodgman(subjectPolygon,clipPolygon)
%The inputs are a table of x-y pairs for the verticies of the subject
%polygon and boundary polygon. (x values in column 1 and y values in column
%2) The output is a table of x-y pairs for the clipped version of the
%subject polygon.
%% Helper Functions

%computerIntersection() assumes the two lines intersect
    function intersection = computeIntersection(line1,line2)
        
        %this is an implementation of
        %http://en.wikipedia.org/wiki/Line-line_intersection
        
        intersection = zeros(1,2);
        
        detL1 = det(line1);
        detL2 = det(line2);
        
        detL1x = det([line1(:,1),[1;1]]);
        detL1y = det([line1(:,2),[1;1]]);
        
        detL2x = det([line2(:,1),[1;1]]);
        detL2y = det([line2(:,2),[1;1]]);
        
        denominator = det([detL1x detL1y;detL2x detL2y]);
        
        intersection(1) = det([detL1 detL1x;detL2 detL2x]) / denominator;
        intersection(2) = det([detL1 detL1y;detL2 detL2y]) / denominator;
        
    end %computeIntersection

%inside() assumes the boundary is oriented counter-clockwise
    function in = inside(point,boundary)
        
        pointPositionVector = [diff([point;boundary(1,:)]) 0];
        boundaryVector = [diff(boundary) 0];
        crossVector = cross(pointPositionVector,boundaryVector);
        
        if ( crossVector(3) <= 0 )
            in = true;
        else
            in = false;
        end
        
    end %inside

%% Sutherland-Hodgman Algorithm

clippedPolygon = subjectPolygon;
numVerticies = size(clipPolygon,1);
clipVertexPrevious = clipPolygon(end,:);

for clipVertex = (1:numVerticies)
    
    clipBoundary = [clipPolygon(clipVertex,:) ; clipVertexPrevious];
    
    inputList = clippedPolygon;
    
    clippedPolygon = [];
    if ~isempty(inputList)
        previousVertex = inputList(end,:);
    end
    
    for subjectVertex = (1:size(inputList,1))
        
        if ( inside(inputList(subjectVertex,:),clipBoundary) )
            
            if( not(inside(previousVertex,clipBoundary)) )
                subjectLineSegment = [previousVertex;inputList(subjectVertex,:)];
                clippedPolygon(end+1,1:2) = computeIntersection(clipBoundary,subjectLineSegment);
            end
            
            clippedPolygon(end+1,1:2) = inputList(subjectVertex,:);
            
        elseif( inside(previousVertex,clipBoundary) )
            subjectLineSegment = [previousVertex;inputList(subjectVertex,:)];
            clippedPolygon(end+1,1:2) = computeIntersection(clipBoundary,subjectLineSegment);
        end
        
        previousVertex = inputList(subjectVertex,:);
        clipVertexPrevious = clipPolygon(clipVertex,:);
        
    end %for subject verticies
end %for boundary verticies
end %sutherlandHodgman
function F=circ_gauss(X,Y,Sigma,center)
%--------------------------------------------------------------------------
% circ_gauss function                                                General
% Description: Calculate 2D circular Gaussian in a 2-D grid.
% Input  : - Scalar, vector or matrix of X-coordinates in which to calculate
%            the 2-D Gaussian.
%          - same as the x-ccordinates, but for the y-axis.
%          - Sigma of the Gaussian or [SigmaX, SigmaY] in case sigma
%            is different for each axis.
%            By default SigmaY=SigmaX.
%            If empty matrix use default.Si
%          - Center of the Gaussian [X, Y].
%            By default Y=X.
%            Default is [0 0].
%            If empty matrix use default.
%          - Maximum radius of Gaussian behond to set it to zero.
%            Default is Inf.
%            MaxRad is measured from the center of the kernel and not
%            the center of the Gaussian.


% Example:
%          F=circ_gauss(MatX,MatY,[1],[0 0]);
%          surface(F);
%--------------------------------------------------------------------------

SigmaX = Sigma(1);
SigmaY = Sigma(2);

X0 = center(1);
Y0 = center(2);

F = 1./(2.*pi.*SigmaX.*SigmaY) .*exp(-1./(2.).* ((X-X0).^2./SigmaX.^2 +(Y-Y0).^2./SigmaY.^2));

F = F./sum(sum(F));

% set elements outside MaxRad to zero:
% if (~isinf(cutoff)),
%    MatR = sqrt(X.^2 + Y.^2);
%    I = find(MatR>cutoff);
%    F(I) = 0;
% end
%
% if (isnan(Norm)),
%    % do not normalize
% else
%    F = Norm.*F./sumnd(F);
% end
end
function C = viridis(N)
%VIRIDIS Blue-green-yellow colour map
%   VIRIDIS(N) returns an N-by-3 matrix containing a colormap. 
%   The colors begin with dark purplish-blue and blue, range
%   through green and end with yellow. 
%   
%   VIRIDIS is the new default colormap for matplotlib
%  
% Created by Ed Hawkins (@ed_hawkins) and Kevin Anchukaitis

viridi = [
0.26700401  0.00487433  0.32941519
0.26851048  0.00960483  0.33542652
0.26994384  0.01462494  0.34137895
0.27130489  0.01994186  0.34726862
0.27259384  0.02556309  0.35309303
0.27380934  0.03149748  0.35885256
0.27495242  0.03775181  0.36454323
0.27602238  0.04416723  0.37016418
0.2770184   0.05034437  0.37571452
0.27794143  0.05632444  0.38119074
0.27879067  0.06214536  0.38659204
0.2795655   0.06783587  0.39191723
0.28026658  0.07341724  0.39716349
0.28089358  0.07890703  0.40232944
0.28144581  0.0843197   0.40741404
0.28192358  0.08966622  0.41241521
0.28232739  0.09495545  0.41733086
0.28265633  0.10019576  0.42216032
0.28291049  0.10539345  0.42690202
0.28309095  0.11055307  0.43155375
0.28319704  0.11567966  0.43611482
0.28322882  0.12077701  0.44058404
0.28318684  0.12584799  0.44496   
0.283072    0.13089477  0.44924127
0.28288389  0.13592005  0.45342734
0.28262297  0.14092556  0.45751726
0.28229037  0.14591233  0.46150995
0.28188676  0.15088147  0.46540474
0.28141228  0.15583425  0.46920128
0.28086773  0.16077132  0.47289909
0.28025468  0.16569272  0.47649762
0.27957399  0.17059884  0.47999675
0.27882618  0.1754902   0.48339654
0.27801236  0.18036684  0.48669702
0.27713437  0.18522836  0.48989831
0.27619376  0.19007447  0.49300074
0.27519116  0.1949054   0.49600488
0.27412802  0.19972086  0.49891131
0.27300596  0.20452049  0.50172076
0.27182812  0.20930306  0.50443413
0.27059473  0.21406899  0.50705243
0.26930756  0.21881782  0.50957678
0.26796846  0.22354911  0.5120084 
0.26657984  0.2282621   0.5143487 
0.2651445   0.23295593  0.5165993 
0.2636632   0.23763078  0.51876163
0.26213801  0.24228619  0.52083736
0.26057103  0.2469217   0.52282822
0.25896451  0.25153685  0.52473609
0.25732244  0.2561304   0.52656332
0.25564519  0.26070284  0.52831152
0.25393498  0.26525384  0.52998273
0.25219404  0.26978306  0.53157905
0.25042462  0.27429024  0.53310261
0.24862899  0.27877509  0.53455561
0.2468114   0.28323662  0.53594093
0.24497208  0.28767547  0.53726018
0.24311324  0.29209154  0.53851561
0.24123708  0.29648471  0.53970946
0.23934575  0.30085494  0.54084398
0.23744138  0.30520222  0.5419214 
0.23552606  0.30952657  0.54294396
0.23360277  0.31382773  0.54391424
0.2316735   0.3181058   0.54483444
0.22973926  0.32236127  0.54570633
0.22780192  0.32659432  0.546532  
0.2258633   0.33080515  0.54731353
0.22392515  0.334994    0.54805291
0.22198915  0.33916114  0.54875211
0.22005691  0.34330688  0.54941304
0.21812995  0.34743154  0.55003755
0.21620971  0.35153548  0.55062743
0.21429757  0.35561907  0.5511844 
0.21239477  0.35968273  0.55171011
0.2105031   0.36372671  0.55220646
0.20862342  0.36775151  0.55267486
0.20675628  0.37175775  0.55311653
0.20490257  0.37574589  0.55353282
0.20306309  0.37971644  0.55392505
0.20123854  0.38366989  0.55429441
0.1994295   0.38760678  0.55464205
0.1976365   0.39152762  0.55496905
0.19585993  0.39543297  0.55527637
0.19410009  0.39932336  0.55556494
0.19235719  0.40319934  0.55583559
0.19063135  0.40706148  0.55608907
0.18892259  0.41091033  0.55632606
0.18723083  0.41474645  0.55654717
0.18555593  0.4185704   0.55675292
0.18389763  0.42238275  0.55694377
0.18225561  0.42618405  0.5571201 
0.18062949  0.42997486  0.55728221
0.17901879  0.43375572  0.55743035
0.17742298  0.4375272   0.55756466
0.17584148  0.44128981  0.55768526
0.17427363  0.4450441   0.55779216
0.17271876  0.4487906   0.55788532
0.17117615  0.4525298   0.55796464
0.16964573  0.45626209  0.55803034
0.16812641  0.45998802  0.55808199
0.1666171   0.46370813  0.55811913
0.16511703  0.4674229   0.55814141
0.16362543  0.47113278  0.55814842
0.16214155  0.47483821  0.55813967
0.16066467  0.47853961  0.55811466
0.15919413  0.4822374   0.5580728 
0.15772933  0.48593197  0.55801347
0.15626973  0.4896237   0.557936  
0.15481488  0.49331293  0.55783967
0.15336445  0.49700003  0.55772371
0.1519182   0.50068529  0.55758733
0.15047605  0.50436904  0.55742968
0.14903918  0.50805136  0.5572505 
0.14760731  0.51173263  0.55704861
0.14618026  0.51541316  0.55682271
0.14475863  0.51909319  0.55657181
0.14334327  0.52277292  0.55629491
0.14193527  0.52645254  0.55599097
0.14053599  0.53013219  0.55565893
0.13914708  0.53381201  0.55529773
0.13777048  0.53749213  0.55490625
0.1364085   0.54117264  0.55448339
0.13506561  0.54485335  0.55402906
0.13374299  0.54853458  0.55354108
0.13244401  0.55221637  0.55301828
0.13117249  0.55589872  0.55245948
0.1299327   0.55958162  0.55186354
0.12872938  0.56326503  0.55122927
0.12756771  0.56694891  0.55055551
0.12645338  0.57063316  0.5498411 
0.12539383  0.57431754  0.54908564
0.12439474  0.57800205  0.5482874 
0.12346281  0.58168661  0.54744498
0.12260562  0.58537105  0.54655722
0.12183122  0.58905521  0.54562298
0.12114807  0.59273889  0.54464114
0.12056501  0.59642187  0.54361058
0.12009154  0.60010387  0.54253043
0.11973756  0.60378459  0.54139999
0.11951163  0.60746388  0.54021751
0.11942341  0.61114146  0.53898192
0.11948255  0.61481702  0.53769219
0.11969858  0.61849025  0.53634733
0.12008079  0.62216081  0.53494633
0.12063824  0.62582833  0.53348834
0.12137972  0.62949242  0.53197275
0.12231244  0.63315277  0.53039808
0.12344358  0.63680899  0.52876343
0.12477953  0.64046069  0.52706792
0.12632581  0.64410744  0.52531069
0.12808703  0.64774881  0.52349092
0.13006688  0.65138436  0.52160791
0.13226797  0.65501363  0.51966086
0.13469183  0.65863619  0.5176488 
0.13733921  0.66225157  0.51557101
0.14020991  0.66585927  0.5134268 
0.14330291  0.66945881  0.51121549
0.1466164   0.67304968  0.50893644
0.15014782  0.67663139  0.5065889 
0.15389405  0.68020343  0.50417217
0.15785146  0.68376525  0.50168574
0.16201598  0.68731632  0.49912906
0.1663832   0.69085611  0.49650163
0.1709484   0.69438405  0.49380294
0.17570671  0.6978996   0.49103252
0.18065314  0.70140222  0.48818938
0.18578266  0.70489133  0.48527326
0.19109018  0.70836635  0.48228395
0.19657063  0.71182668  0.47922108
0.20221902  0.71527175  0.47608431
0.20803045  0.71870095  0.4728733 
0.21400015  0.72211371  0.46958774
0.22012381  0.72550945  0.46622638
0.2263969   0.72888753  0.46278934
0.23281498  0.73224735  0.45927675
0.2393739   0.73558828  0.45568838
0.24606968  0.73890972  0.45202405
0.25289851  0.74221104  0.44828355
0.25985676  0.74549162  0.44446673
0.26694127  0.74875084  0.44057284
0.27414922  0.75198807  0.4366009 
0.28147681  0.75520266  0.43255207
0.28892102  0.75839399  0.42842626
0.29647899  0.76156142  0.42422341
0.30414796  0.76470433  0.41994346
0.31192534  0.76782207  0.41558638
0.3198086   0.77091403  0.41115215
0.3277958   0.77397953  0.40664011
0.33588539  0.7770179   0.40204917
0.34407411  0.78002855  0.39738103
0.35235985  0.78301086  0.39263579
0.36074053  0.78596419  0.38781353
0.3692142   0.78888793  0.38291438
0.37777892  0.79178146  0.3779385 
0.38643282  0.79464415  0.37288606
0.39517408  0.79747541  0.36775726
0.40400101  0.80027461  0.36255223
0.4129135   0.80304099  0.35726893
0.42190813  0.80577412  0.35191009
0.43098317  0.80847343  0.34647607
0.44013691  0.81113836  0.3409673 
0.44936763  0.81376835  0.33538426
0.45867362  0.81636288  0.32972749
0.46805314  0.81892143  0.32399761
0.47750446  0.82144351  0.31819529
0.4870258   0.82392862  0.31232133
0.49661536  0.82637633  0.30637661
0.5062713   0.82878621  0.30036211
0.51599182  0.83115784  0.29427888
0.52577622  0.83349064  0.2881265 
0.5356211   0.83578452  0.28190832
0.5455244   0.83803918  0.27562602
0.55548397  0.84025437  0.26928147
0.5654976   0.8424299   0.26287683
0.57556297  0.84456561  0.25641457
0.58567772  0.84666139  0.24989748
0.59583934  0.84871722  0.24332878
0.60604528  0.8507331   0.23671214
0.61629283  0.85270912  0.23005179
0.62657923  0.85464543  0.22335258
0.63690157  0.85654226  0.21662012
0.64725685  0.85839991  0.20986086
0.65764197  0.86021878  0.20308229
0.66805369  0.86199932  0.19629307
0.67848868  0.86374211  0.18950326
0.68894351  0.86544779  0.18272455
0.69941463  0.86711711  0.17597055
0.70989842  0.86875092  0.16925712
0.72039115  0.87035015  0.16260273
0.73088902  0.87191584  0.15602894
0.74138803  0.87344918  0.14956101
0.75188414  0.87495143  0.14322828
0.76237342  0.87642392  0.13706449
0.77285183  0.87786808  0.13110864
0.78331535  0.87928545  0.12540538
0.79375994  0.88067763  0.12000532
0.80418159  0.88204632  0.11496505
0.81457634  0.88339329  0.11034678
0.82494028  0.88472036  0.10621724
0.83526959  0.88602943  0.1026459 
0.84556056  0.88732243  0.09970219
0.8558096   0.88860134  0.09745186
0.86601325  0.88986815  0.09595277
0.87616824  0.89112487  0.09525046
0.88627146  0.89237353  0.09537439
0.89632002  0.89361614  0.09633538
0.90631121  0.89485467  0.09812496
0.91624212  0.89609127  0.1007168 
0.92610579  0.89732977  0.10407067
0.93590444  0.8985704   0.10813094
0.94563626  0.899815    0.11283773
0.95529972  0.90106534  0.11812832
0.96489353  0.90232311  0.12394051
0.97441665  0.90358991  0.13021494
0.98386829  0.90486726  0.13689671
0.99324789  0.90615657  0.1439362];

P = size(viridi,1);

if nargin < 1
   N = P;
end

N = min(N,P);
C = interp1(1:P, viridi, linspace(1,P,N), 'linear');
end
