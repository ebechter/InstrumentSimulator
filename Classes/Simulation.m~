classdef Simulation
    properties
        scale
        totalCounts
        totalEnergy
        
    end
    
    methods
        function obj = Simulation(scale)
            
            if nargin == 0
                obj.scale = 1;
            else
                obj.scale = scale;
            end
        end

    end
    
    methods(Static)
        
        function [sampledstar] = addStar(R,pixSamp,scale,wavelength,spectrum,rv)
            
            
            % Define wavelength step (input in microns, output in microns) using maximum resolving power (R),
            % pixSamp, and scale factor
            dlam = 1/R/pixSamp;
            step = dlam/scale;
            interplambda = wavelength(1):step:wavelength(end);
            interpflux = interp1(wavelength, spectrum, interplambda,'linear');
            
            dsWavelength = Star.dopplerShift(interplambda,rv); %Shift Wavelength and assign DsWavelength
            counts = Star.energy2Counts(dsWavelength,interpflux);
            sampledstar = [dsWavelength;counts]';
            
            
        end
        
        function [counts] = addCollectingArea(countsPerArea,dTel,blockFrac)
            
            collecting_area = pi*(dTel/2)^2 - pi*(blockFrac*dTel/2)^2;
            counts = countsPerArea * collecting_area;
            
        end
        
        function [y_grid] = resampleToGrid(x,y,x_grid)
            % this function cuts a new x vector and the max of the original and
            % extrapolates the short end of the new x vector to the short end of the
            % original x vector. The new y vector for use is generated by interpolating the
            % new_x,new_y onto the original x vector.
            
            extrap_scalar = min(y);
            ub = min(x(end,1),x_grid(end,1));
            ind = find(x<=ub,1,'last');
            x_safe = x(1:ind);
            y_safe = y(1:ind);
            
            y_grid = interp1(x_safe(:,1),y_safe(:,1),x_grid,'linear',extrap_scalar);
            
        end
        
        function [addtell] = addAtmosphere(wavelength,counts, telluric, skyback)
            
            skygrid = Simulation.resampleToGrid(skyback(:,1),skyback(:,2),wavelength);
            
            addsky = counts + skygrid;
            
            tellgrid = Simulation.resampleToGrid(telluric(:,1),telluric(:,2),wavelength);
            
            addtell = addsky.*tellgrid;
            
        end
        
        function [starThroughput,comTput] = combineImagerThroughput(star_components)
            comTput{1,1} = star_components(1).finalThroughput;
            comTput{2,1} = star_components(1).name;
            
            for ii = 2:size(star_components,2) %loop over cellarry size (i.e. surfaces)
                [comTput{1,ii}(:,1),comTput{1,ii}(:,2)] = Instrument.multiply_curves...
                    (comTput{1,ii-1}(:,1),comTput{1,ii-1}(:,2),...
                    star_components(ii).finalThroughput(:,1),star_components(ii).finalThroughput(:,2));
                
                comTput{2,ii} = star_components(ii).name; % add the object name to the cell array for progression plots
            end
            
            starThroughput = comTput{1,end};
        end
        
        function [output] = Xdisperse(inputSpectrum,nOrders,waveCoeff)
            
            
            temp{1} = repmat(inputSpectrum(:,1)',nOrders,1)';
            temp{2} = repmat(inputSpectrum(:,2)',nOrders,1)';
            
            
            [outputWavelength, outputOrders] = Simulation.trimOrders(temp{1}, temp{2}, waveCoeff,nOrders);
            
            
            output{1} = outputWavelength;
            output{2} = outputOrders;
            
        end
        
        function [OutWavelength, OutSpectrum] = trimOrders (wavelength,spectrum,wave_coeff,nOrders)
            
            ord = size(spectrum, 2); % what is the largert order (39)
            buffer_edge = 25; %set detector edge (buffered by 5mm)
            
            ind_lim1 = find(wavelength(:,ord) <= polyval(wave_coeff(ord,:,1),-buffer_edge),1,'last');
            ind_lim2 = find(wavelength(:,ord) >= polyval(wave_coeff(ord,:,1), buffer_edge),1,'first');
            max_length = (ind_lim2-ind_lim1); % find the length of the largest order with buffer
            
            for ii = 1:nOrders
                
                ind1 = find(wavelength(:,ii) <= polyval(wave_coeff(ii,:,1), -buffer_edge),1,'last');
                ind2 = max_length + ind1; % ind2 is forced to match largest order size
                %                 disp(ind2-ind1) %check all orders are the same size
                OutWavelength(:,ii) = wavelength(ind1:ind2,ii);
                OutSpectrum(:,ii) = spectrum(ind1:ind2,ii);
                %                 disp(ii)
            end
            
        end
        
        function [output] = addSpecThroughput(spectral_cell,finalThroughput,nOrders)
            
            for ii = 1:nOrders
                new_y = Simulation.resampleToGrid(finalThroughput{2}(:,ii)*1e-3,finalThroughput{1}(:,ii),spectral_cell{1}(:,ii));
                output{1}(:,ii) = spectral_cell{1}(:,ii);
                output{2}(:,ii) = new_y .* spectral_cell{2}(:,ii);
                
            end
            
        end
        
        function [PSF,center] = MakePSF(scale,pix_samp,vert_samp)
            
            % dispersion direction
            fwhm = pix_samp*scale;
            sigmax=fwhm/(2*sqrt(2*log(2)));
            
            % cross dispersion direction
            fwhmy = vert_samp*scale;
            sigmay=fwhmy/(2*sqrt(2*log(2)));
            
            % trim according to bigger dimension
            Nsigmas = 9;
            val = Nsigmas * sigmay;
            %
            
            %             clip = 3/(2*sqrt(2*log(2)));
            %             val = 25*clip;
            
            oddGrid=2*round(val/2)-1; % not super important but lets go with an odd grid size every time
            
            [MatX,MatY]=meshgrid(1:1:oddGrid,1:1:oddGrid); % make the mesh grid
            
            center = [round(size(MatX,2)/2),round(size(MatY,1)/2)]; % center x and y in the (likely) non-integer center of grid ;
            % this is the most important line - the center of the PSF must fall in a pixel center
            % subtract the center in the x direction from the full convolution to get a "central" conv. result
            %....maybe not certain.
            
            PSF=circ_gauss(MatX,MatY,[sigmax,sigmay],center);
            
            
        end
        
        function [APSF,FPgridx,FPgridy] = makeAbPsf(wfe,wavelength,pixSamp,scale)
          
            % wavelength = 1;% microns
            % wfe = [0,0,0,0,0,0,0,0];
            
            %Zernike phase map
            W = 0; %
            for z = 1:length(wfe)
                Z = ZernikeCalc(z,1,scale*17); % use ZernikeCalc to produce normalized zernike surface
                %     Z = padarray(Z,[400,400]);% increase padding on output;
                Z = Z./(max(max(Z)));
                Ab = wfe(z)*Z;
                W = W+Ab;
            end
            
            %Constants (we should make this accept variables, or use
            %defaults)
            N = size(W,1);% variable 7/25/17 Sampling points
            L = 50e-3;% length of grid in meters
            dl = L/N; %Pupil plane grid spacing (meters)
            beamD = (3/pixSamp(1))*(1/scale)*20e-3*(0.883);
            beamDy =(3/pixSamp(2))*(1/scale)*20e-3*(0.883);
            D = 1.75*beamD;%5.8e-3; % Pupil diameter
            
            k = 2*pi./(1e-6*wavelength); %wavenumber
            alpha = 0.11; % secondary blocking fraction
            f = 1.33*440e-3;%24.5e-3;% (20.8e-3) focal length of lens
            d = f; %distance before the lens
            
            %Pupil definition
            [x1,y1] = meshgrid((-N/2+0.5:N/2-0.5)*dl); %grid in pupil plane
            PPgrid(:,:,1) = x1;
            PPgrid(:,:,2) = y1;
            
            
            PupilOffset = 0; %1mm offset
            Pupil_cenx = x1 + PupilOffset;
            Pupil_ceny = y1 + PupilOffset;
            Uin1 = circ(Pupil_cenx,Pupil_ceny,D);%outer circle
            % Uin2 = circ(Pupil_cenx,Pupil_ceny,D*alpha);%inner circle
            % pupil = Uin1-Uin2;%total pupil plance image
            
            [gauss]=circ_gauss(Pupil_cenx,Pupil_ceny,[beamD/4,beamDy/4],[0,0]);
            gauss = gauss./(max(max(gauss)));
            pupil = Uin1.*gauss;
            
            % W =pupil.*W;
            Pupil = pupil.*exp(1i*W); %Complex Pupil plane with phase term
            
            %Propogate the pupil plane to focal plane (electric fields) at
            %all wavelengths
            [x2,y2,PSF] = lens_in_front_ft(Pupil,1e-6*wavelength,dl,f,d);
            FPgridx = x2;
            FPgridy = y2;
            
            APSF = abs(PSF).^2;
            APSF = APSF./(sum(sum(APSF)));
        end

        function [trim, wavelength] = ConvolveOrder(wavelength,spectrum,wave_coeff,wfe,scale)
            
            % trim each order beyond the edge of the detector
            
            ind1 = find(wavelength <= polyval(wave_coeff,-22.48),1,'last');
            ind2 = find(wavelength >= polyval(wave_coeff, 22.48),1,'first');
            
            wavelength = wavelength(ind1:ind2)';
            spectrum = spectrum(ind1:ind2)';
            
            % sampled at the high end. 3 pixels at red, smooth function to
            % 6 pixels at blue.
            
            horSamp = linspace(6,3,length(wavelength));
            
            vertSamp = median(horSamp);
            horSamp = 0.8*horSamp;
            % Custom convolution
            
            % Do the first loop iteration outside the loop. Need to
            % calculate dim first
            ii = 1;
            
            % Determine wfe to use. scale it off of wavelength... 
            wfeList{ii} = wfe*(wavelength(ii)/0.97);
            [APSF,FPgridx,FPgridy] = Simulation.makeAbPsf(wfeList{ii},wavelength(ii),[horSamp(ii) vertSamp],scale);
            center = [round(size(FPgridx,2)/2),round(size(FPgridy,1)/2)];

            
            % No aberrations
            [PSF,center] = Simulation.MakePSF(scale,horSamp(ii),vertSamp);
            dim = size(PSF,1);
            rectangle = zeros(dim,length(wavelength)+dim-1);
            rectangle(:,ii:dim-1+ii)=rectangle(:,ii:dim-1+ii)+PSF.*spectrum(ii);
            
            for ii = 2:length(wavelength)

                wfeList{ii} = wfe*(wavelength(ii)/0.97);
%                 [PSF,~,~] = Simulation.makeAbPsf(wfeList{ii},wavelength(ii),[horSamp(ii) vertSamp],scale);

                [PSF,~] = Simulation.MakePSF(scale,horSamp(ii),vertSamp);
                
                %                 Conv1 = conv2(spectrum(ii),PSF,'full');
                
                rectangle(:,ii:dim-1+ii)=rectangle(:,ii:dim-1+ii)+PSF.*spectrum(ii);
                %                 rectangle(:,ii:dim-1+ii)=rectangle(:,ii:dim-1+ii)+Conv1;
                
                
            end
            
            
            trim = rectangle(:,center(1):end-(size(PSF,2)-center(1)));
            
        end
        
        function detector = CliptoDetector(order,wavelength,order_coeff,wave_coeff,cheby,p1,specorder)
            
            
            % convert each xypair into a set of 4 verticies for the pixel. Depends on PSF scaling etc..
            % from PSF convolution - know what one square "sample" is in mm. Does that still work after convolution?
            %% XY location pair for each point on wavelength vector
            xy_pair = zeros([size(order),2]);
            
            [~,beta] = max(order);
            center = mode(beta);
            
            % Convert lambda to X based on Zemax order fit
            % new x  =  interpolate (lam,x,lam')
            
            %             xy_pair(center,:,1) = interp1( polyval(wave_coeff,((1:0.1:4096)-2048)/100)  , ((1:0.1:4096)-2048)/100   ,wavelength,'linear','extrap');
            
            %             xy_pair(center,:,1) = interp1( polyval(wave_coeff,-25.48:0.00001:25.48), (-25.48:0.00001:25.48) ,wavelength,'linear','extrap');
            
            % Chebyshev 2D polynomial wavelength interpolation.
            specorder = 40-specorder;
            if cheby == 1
                Inverse =1;
                nx = 7;
                nm = 7;
                ntotal = 39;
                npix = 4096;
                order0 = 113;
                finex=-25.48:0.01:25.48;
                fineorders = specorder*ones(size(finex)); % what spectral order are we at?
                finechebs = Calculate_chebs(finex, fineorders+order0,Inverse,order0,ntotal,npix,nx,nm); 
                finewavelengths = JointFitFunc(p1,finechebs,fineorders+order0,nx,nm); 
                
                xy_pair(center,:,1) = interp1( finewavelengths,finex,wavelength,'linear','extrap');
                
            else
                % using 4th order, 1D polynomial needs interpolation. Inversion
                % is not possible.
                xy_pair(center,:,1) = interp1( polyval(wave_coeff,-25.48:0.00001:25.48), (-25.48:0.00001:25.48) ,wavelength,'linear','extrap');
            end
            
            % Inverting the 2nd order 1D polynomial
            %             a = wave_coeff(1);
            %             b = wave_coeff(2);
            %             c = wave_coeff(3);
            %
            %             xy_pair(center,:,1) = (-b + sqrt(b^2-4*a*(c-wavelength)))/(2*a);
            
            
            % fprintf('Counts before detector: %.5f', sum(sum(order)))
            %% This makes the order flat
            %              test = xy_pair(center,1,1).*ones(1,size(order,2));
            %              xy_pair(center,:,2) = polyval(order_coeff,test);
            
            
            xy_pair(center,:,2) = polyval(order_coeff,xy_pair(center,:,1));
            
            % multiply by 100 to convert x,y mm to pixels then move 0,0 from center to bottom left
            xy_pair =xy_pair*100+4096/2;
            
            delta_w = diff(wavelength)/2;
            delta_w = [delta_w delta_w(end)];
            
            edges_w = [wavelength(1)-delta_w(1) wavelength+delta_w];
            if cheby ==1
                edges_x = interp1( finewavelengths, finex ,edges_w,'linear','extrap');
            else
                edges_x = interp1( polyval(wave_coeff,-25.48:0.00001:25.48), (-25.48:0.00001:25.48) ,edges_w,'linear','extrap');
            end
            %             edges_x = (-b + sqrt(b^2-4*a*(c-edges_w)))/(2*a);
            edges_x = edges_x*100+4096/2;
            
            
            %             offset = xy_pair(center,2:size(xy_pair,2),1)-xy_pair(center,1:size(xy_pair,2)-1,1);
            %             offset = [offset offset(end)];
            
            yoffset = [center-1:-1:1 0 -(1:size(order,1)-center)];
            
            detector = zeros(4096+4,4096+4); % 4096x4096 + 2 extra for padding
            
            %%% XY center pairs for entire order
            
            % xy_pair(vertical scalar index, horizontal vector of length, x and y)
            
            for jj = 1:size(xy_pair,2)
                for ii = [1:center-1 center+1:size(order,1)]
                    xy_pair(ii,jj,1) = xy_pair(center,jj,1);
                    %                     xy_pair(ii,jj,2) = xy_pair(center,jj,2)+ yoffset(ii)*offset(1);
                    xy_pair(ii,jj,2) = xy_pair(center,jj,2)+ yoffset(ii)*mean(diff(edges_x));
                    
                end
            end
            
            
            for ii = [1:center-1 center center+1:size(order,1)]
                
                for jj =1:size(xy_pair,2)
                    %                     xlist{ii}{jj} = xy_pair(ii,jj,1) + [-1 1 1 -1 -1]*offset(jj)/2 ; %x starting at top left, clockwise
                    %                     ylist{ii}{jj} = xy_pair(ii,jj,2) + [1 1 -1 -1  1]*offset(1)/2; % y ***extra final point to draw box
                    xlist{ii}{jj} = [edges_x(jj) edges_x(jj+1) edges_x(jj+1) edges_x(jj) edges_x(jj)];
                    ylist{ii}{jj} = xy_pair(ii,jj,2) + [1 1 -1 -1  1]*mean(diff(edges_x))/2; % y ***extra final point to draw box
                    
                    % +1 to the x and y list to account for a 1 cell padd
                    % to remove edge clipping errors.
                    [area,ind]=polyfillaa(2+xlist{ii}{jj},2+ylist{ii}{jj},4+4096, 4+4096);
                    ind = ind+1;
                    detector(ind) = detector(ind)+order(ii,jj).*area./sum(area);
                    clear ind area
                end
                
            end
            
            
            detector = detector(3:end-2,3:end-2); % remove padding
            detector = detector';
            
            
            
            % Plotting - be careful with this
            %             figure(100);
            %             hold on
            %
            %             for jj = 1:200%size(order,2)
            %
            %                 for ii = [1:center-1 center center+1:size(order,1)]
            %
            %
            % %                     plot(xy_pair(:,jj,1),xy_pair(:,jj,2),'.k')
            %
            %                     plot(xlist{ii}{jj},ylist{ii}{jj},'-','color',colors{rem(jj,length(colors)-1)+1})
            %
            %
            %
            %                 end
            %             end
            
            
        end
        
        function WriteFits(filename,image,headerinfo)
            
            import matlab.io.*
            DataType = 'single';
            % create fits file
            fptr = fits.createFile(filename);
            
            % Create Image extension
            fits.createImg(fptr,DataType,size(image));
            
            % Write image to file
            fits.writeImg(fptr,image);
            
            % Write additional keywords
            for ii = 1:size(headerinfo,1)
                fits.writeKey(fptr,headerinfo{ii,1},headerinfo{ii,2},headerinfo{ii,3});
                
            end
            % close file
            fits.closeFile(fptr);
            
        end
        
        function [trimWave,trimCounts] = trimToBand(wavelength,counts,bandPass)
            
            ind = wavelength<=bandPass(2) & wavelength>=bandPass(1);
            
            trimWave = wavelength(ind);
            trimCounts = counts(ind);
            
            
        end
        
        function [SR_interp] = calculateStrehlRatio(aoType,seeing,counts,zenith)
            strehl_dir = pwd;
            refS=[0.6,0.8,1];
            [~,indmatch] = min(abs(refS-seeing));
            
            if strcmp(aoType,'FLAO') == 1
                file = '/RefFiles/AO/FLAO_Strehl.csv';
                refSeeing = 1;
            else
                if indmatch == 1
                    file = '/RefFiles/AO/SOUL_Strehl_06_vib.csv';
                    refSeeing = refS(indmatch);
                elseif indmatch == 2
                    file = '/RefFiles/AO/SOUL_Strehl_08_vib.csv';
                    refSeeing = refS(indmatch);
                elseif indmatch == 3
                    file = '/RefFiles/AO/SOUL_Strehl_1_vib.csv';
                    refSeeing = refS(indmatch);
                end
            end
            
            filename = strcat(strehl_dir,file); % found the closest reference filename for this AO system
            
            %--------------------------------------------------------------------------%
            %--------------------------------------------------------------------------%
            %Description: Read in reference WFS file from LBT ao group
            
            delimiter = ',';
            startRow = 2;
            endRow = inf;
            formatSpec = '%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%[^\n\r]';
            
            % Open the text file.
            fileID = fopen(filename,'r');
            dataArray = textscan(fileID, formatSpec, endRow(1)-startRow(1)+1, 'Delimiter', delimiter, 'HeaderLines', startRow(1)-1, 'ReturnOnError', false);
            for block=2:length(startRow)
                frewind(fileID);
                dataArrayBlock = textscan(fileID, formatSpec, endRow(block)-startRow(block)+1, 'Delimiter', delimiter, 'HeaderLines', startRow(block)-1, 'ReturnOnError', false);
                for col=1:length(dataArray)
                    dataArray{col} = [dataArray{col};dataArrayBlock{col}];
                end
            end
            % Close the text file.
            fclose(fileID);
            
            % Allocate imported array to column variable names
            MagR = dataArray{:, 1}; %r amgnitude
            SRR = dataArray{:, 2}; %R band Strehl ratio
            SRI = dataArray{:, 3}; %I band Strehl ratio
            SRY = dataArray{:, 4}; %Y band Strehl ratio
            SRJ = dataArray{:, 5}; %J band Strehl ratio
            SRH = dataArray{:, 6}; %H band Strehl ratio
            SRK = dataArray{:, 7}; %K band Strehl ratio
            SRL = dataArray{:, 8}; %L band Strehl ratio
            SRM = dataArray{:, 9}; %M band Strehl ratio
            Totalnm = dataArray{:, 10}; % total nm (not sure what this is)
            bin = dataArray{:, 11}; % WFS binning mode
            modamplD = dataArray{:, 12}; % not sure what this is I/D are units
            fsHz = dataArray{:, 13}; % frame rate in Hz
            fluxphfr = dataArray{:, 14}; % photons/frame
            fluxphfrsa = dataArray{:, 15}; % photons/frame/sub aperture
            fluxphfrpix = dataArray{:, 16}; % photons/frame/pixel
            modes1 = dataArray{:, 17}; % number of AO modes
            Photmodes = dataArray{:, 18}; %photons /mode
            gain = dataArray{:, 19}; % gain
            TTgain = dataArray{:, 20}; % tip/tilt gain
            
            %--------------------------------------------------------------------------%
            %--------------------------------------------------------------------------%
            %Description: Calcaulte the Strehl ratio based on incident photons to WFS
            %Inputs: photons/second/subaperture. The # of subapertures depends on the binning mode.
            %The FLAO system has 30 max across the pupil which is reduced by binning.
            
            %******* I believe the AO group sent data which double counted the binning
            %effect of their detector. I've checked this using their own numbers send
            %by Guido and rechecked again 3/6/19. 1.99E10 ph/s/m^2 is the 0th order NGS
            %(close to G2). Using this and 0.32 (0.29 in paper) throughput for
            %atmosphere, LBT, WFS, the total number of photons calculated is more than
            %the LBTI reference files by a factor of the binning squared. Thus to
            %remove the error, we need to multiply the refernce file numbers by the binning squared. Ultimately
            %we get the same strehl ratio for a G2 star at all the rights magnitudes. I
            %never got around to bringing this up with them...
            
            phfr= (fluxphfr(:,1).*(bin.^2)); %remove double binning effect by multiplying binning factor squared
            phs = phfr(:,1).*fsHz; %photons/second
            
            % phfrpix_binned = fluxphfrpix(:,1).*(bin.^2);
            % phfrpix = fluxphfrpix(:,1);
            % phfrpixppl = phfrpix/4;
            
            high = max(phs);
            low  = 0;
            num = 1000000;
            xq = linspace(low,high,num);
            vqy = interp1(phs,SRY,xq,'pchip');
            vqj = interp1(phs,SRJ,xq,'pchip');
            vqr = interp1(phs,SRR,xq,'pchip');
            vqi = interp1(phs,SRI,xq,'pchip');
            vqh = interp1(phs,SRH,xq,'pchip');
            vqk = interp1(phs,SRK,xq,'pchip');
            vql = interp1(phs,SRL,xq,'pchip');
            vqm = interp1(phs,SRM,xq,'pchip');
            
            if counts > high
                StrehlY = max(vqy);
                StrehlJ = max(vqj);
                StrehlR = max(vqr);
                StrehlI = max(vqi);
                StrehlH = max(vqh);
                StrehlK = max(vqk);
                StrehlL = max(vql);
                StrehlM = max(vqm);
                ind = 1;
            else
                ind = find(xq>counts,1,'first');
                StrehlY = vqy(ind);
                StrehlJ = vqj(ind);
                StrehlR = vqr(ind);
                StrehlI = vqi(ind);
                StrehlH = vqh(ind);
                StrehlK = vqk(ind);
                StrehlL = vql(ind);
                StrehlM = vqm(ind);
            end
            
            if strcmp(aoType,'FLAO') == 1
                fs = [1000.1 1000.01 1000.001 1000.0001 200 100];
                bin = [1.0001 1.001 2 4 4.0001 4.001 4.01];
            else
                fs = [1500.1 1500.01 1250 750 300 100];
                bin = [1.0001 1.001 1.01 2 3 4];
            end
            
            ref_SR = [StrehlR,StrehlI,StrehlY,StrehlJ,StrehlH,StrehlK,StrehlL,StrehlM]./100; %Strehl ratio samples points units : 0-1;
            
            %--------------------------------------------------------------------------%
            %--------------------------------------------------------------------------%
            %Description: Rescale the Strehl ratio as a function of seeing
            %Input: Strehl ratio from 0-1, seeing in arcseconds
            %Documentation: assume the SR scales as exp(-sigma^2), and sigma^2
            %scales as is (1/r0)5/3. (found in Andreas Quirrenbach citation...).
            % seeing angle ~ lambda/r0 so r0 ~ 1/seeing for a given wavelength
            % r1/r2 = seeing1/seeing2 at a lambda
            
            SR = exp((seeing/refSeeing)^(5/3).*log(ref_SR)); % rescale the Strehl ratio based on seeing ;
            
            %--------------------------------------------------------------------------%
            %--------------------------------------------------------------------------%
            %Description: Rescale the Strehl ratio as a function of zenith angle
            %Input: Strehl ratio from 0-1, zenith angle in radians
            %Documentation:
            %Roddier A0 Textbook and Devaney 2007
            %SR = exp(-sigma^2)
            %r0 ~ cos(z)^3/5 scale factor for seeing angle (from Francois Roddier AO book)
            %The intention is to rescale the freid parameter which is buried in a
            %constant exp -(A/ro)^-5/3 or exp(-B). ro scales as cos(z)^3/5 then the constant (B) scales
            %as (cos(z)^3/5)^-5/3 which is just sec(z)
            %SR(zenith) = exp(-alog(SR(0)) * airmass(zenith)) = exp(-alog(SR(0)) * (seeing(zenith)/seeing(0))^(5./3.))
            %where
            %seeing(zenith) = seeing(0)*airmass(zenith)^(3./5.)
            %airmass(zenith) = 1./cos(zenith/180.*!pi)
            %--------------------------------------------------------------------------%
            
            B = abs(log(SR));% constant
            scale = sec(zenith);%.^(3/5).^(5/3); % also known as sec(z)
            SR_z = exp(-B.*scale);% rescale the strehl ratio and multiply by 100 to get back to % Strehl
            
            %--------------------------------------------------------------------------%
            %--------------------------------------------------------------------------%
            %Description: Interpolate the Strehl Ratio samples over wavlength band using
            % pchip method.
            %Input: Strehl ratio from 0-1 and wavelength samples in microns
            %Documentation:
            % Interpolation method is quick and easy for a smooth SR in ilocater band.
            % This could be replaced in the future by analytic scaling (fried parameter
            % ,r0,scales as lambda^(6/5), so a fitting method could be
            % used as well
            
            Strehl = SR_z;
            step = 1E-4; % sampling in microns
            Band_centers = [0.640,0.750,1.020,1.250,1.650,2.200,3.805,4.781];% from SOUL Excel document header information
            xq = Band_centers(1,1):step:Band_centers(1,end); %generate highly sampled wavelength vector
            SR = interp1(Band_centers, Strehl,xq,'pchip');
            SR_interp(:,1) = xq;
            SR_interp(:,2) = SR;
            
        end

        function [] = ProgressionPlot(compTput)
            handle =[];
            
            %% Custom color lists, yo
            d = get(groot,'DefaultAxesColorOrder');
            for ii = 1:7
                colors{ii}=d(ii,:);
            end
            colors{8}= [0.175 0.175 0.175];
            colors{9}= colors{2};
            colors{10}= colors{3};
            colors{11} =[0 0.3 0];
            clear d
            
            labels = [];
            for ii = 1:size(compTput,2)
                temp{1} = compTput{2,ii};
                labels = [labels;temp];
            end
            
            m = size(compTput,2);
            
            if strcmp(labels(end),'Spectrograph')
                
                n = m - 1;
            else
                n = m;
            end
            
            
            figure
            hold on

            for ii = 1:n
                h{ii} = plot(compTput{1,ii}(:,1),compTput{1,ii}(:,2),'.','Markersize',8,'Color',colors{ii});
                handle = [handle h{ii}];
            end
            
            if n~= m
            
            for jj = 1:size(compTput{1,m}{1,2},2)
                h{ii+1}=plot(compTput{1,m}{1,1}(:,jj),compTput{1,m}{1,2}(:,jj),'.','Color',colors{11},'Markersize',8);
                if jj == 1
                    handle = [handle h{ii+1}];
                end
            end
            
            end
            
            l=legend(handle,labels,'Location','best');
            ylim([0 1])
            xlim([900 1350])
            ylabel('Throughput')
            xlabel('\lambda nm')
            l.FontSize = 10;
            l.Box = 'off';
            box on
            ax = gca;
            ax.LineWidth = 1.5;
        end
        
        function [frame] = simulateImager(psf,dimensions,pixelpitch,totalCounts)
            
            %create the frame based on detector specs
            rows = dimensions(1);
            columns = dimensions(2);
            [MatX,MatY]=meshgrid(1:columns,1:rows); % make the mesh grid
            
            %PSF parameters (gaussian for now)
            sigmax = psf./2.355./pixelpitch; %sigma in pixel units 
            sigmay = sigmax;
            center(1) = round(rows/2);
            center(2) = round(columns/2);
            
            %noiseless frame
            PSF=circ_gauss(MatX,MatY,[sigmax,sigmay],center);
            
            %convolve
            frame = conv2(PSF,totalCounts);
            
        end
        
        
    end
end

function [areas,ret] = polyfillaa(px,py,sx,sy)



% Clip grid to the enclosing box

left = max(floor(min(px)),0);
right = min(floor(max(px)),sx-1);
bottom = max(floor(min(py)),0);
top = min(floor(max(py)),sy-1);
nx=right-left+1;
ny=top-bottom+1;


if nx < 1 || ny < 1
    
    %     disp('clipping missed grid')
    ret = 0;
    areas = 0;
    return
end

%npix is the maximum possible number of clipped polys
npix=nx*ny;

if npix <= 0
    %     disp('clipping missed grid')
    ret = 0;
    areas = 0;
    return
end

ind = 1;

areas = [];%zeros(1,npix);
ret = [];%zeros(1,npix);
%
% figure(1)
% plot([px,px(1)],[py,py(1)],'-k')

for p = 1
    px1 = px;
    py1 = py;
    
    
    for j = bottom(p):top(p)
        for i =left(p):right(p)
            px_out = px1;
            py_out = py1;
            %             polyclip(i,j,px_out,py_out)
            Polygon=[px_out;py_out]';
            unitPixel = [i,i+1,i+1,i;j,j,j+1,j+1]';
            
            clippedPolygon = sutherlandHodgman(Polygon,unitPixel);
            %             figure(1)
            %             hold on
            
            
            if isempty(clippedPolygon) ==1
                continue
                
            end
            %             plot([clippedPolygon(:,1)',clippedPolygon(1,1)],[clippedPolygon(:,2)',clippedPolygon(1,2)],'-o')
            
            
            ret(ind)=i+j*sx;
            
            
            px_out = clippedPolygon(:,1);
            py_out = clippedPolygon(:,2);
            
            
            
            areas(ind) = abs(sum(px_out.* circshift(py_out,-1)-py_out.*circshift(px_out,-1))./2);
            ind = ind+1;
        end
    end
end


zero_ind = find(areas==0);
areas(zero_ind)=[];
ret(zero_ind)=[];

end
function clippedPolygon = sutherlandHodgman(subjectPolygon,clipPolygon)
%The inputs are a table of x-y pairs for the verticies of the subject
%polygon and boundary polygon. (x values in column 1 and y values in column
%2) The output is a table of x-y pairs for the clipped version of the
%subject polygon.
%% Helper Functions

%computerIntersection() assumes the two lines intersect
    function intersection = computeIntersection(line1,line2)
        
        %this is an implementation of
        %http://en.wikipedia.org/wiki/Line-line_intersection
        
        intersection = zeros(1,2);
        
        detL1 = det(line1);
        detL2 = det(line2);
        
        detL1x = det([line1(:,1),[1;1]]);
        detL1y = det([line1(:,2),[1;1]]);
        
        detL2x = det([line2(:,1),[1;1]]);
        detL2y = det([line2(:,2),[1;1]]);
        
        denominator = det([detL1x detL1y;detL2x detL2y]);
        
        intersection(1) = det([detL1 detL1x;detL2 detL2x]) / denominator;
        intersection(2) = det([detL1 detL1y;detL2 detL2y]) / denominator;
        
    end %computeIntersection

%inside() assumes the boundary is oriented counter-clockwise
    function in = inside(point,boundary)
        
        pointPositionVector = [diff([point;boundary(1,:)]) 0];
        boundaryVector = [diff(boundary) 0];
        crossVector = cross(pointPositionVector,boundaryVector);
        
        if ( crossVector(3) <= 0 )
            in = true;
        else
            in = false;
        end
        
    end %inside

%% Sutherland-Hodgman Algorithm

clippedPolygon = subjectPolygon;
numVerticies = size(clipPolygon,1);
clipVertexPrevious = clipPolygon(end,:);

for clipVertex = (1:numVerticies)
    
    clipBoundary = [clipPolygon(clipVertex,:) ; clipVertexPrevious];
    
    inputList = clippedPolygon;
    
    clippedPolygon = [];
    if ~isempty(inputList)
        previousVertex = inputList(end,:);
    end
    
    for subjectVertex = (1:size(inputList,1))
        
        if ( inside(inputList(subjectVertex,:),clipBoundary) )
            
            if( not(inside(previousVertex,clipBoundary)) )
                subjectLineSegment = [previousVertex;inputList(subjectVertex,:)];
                clippedPolygon(end+1,1:2) = computeIntersection(clipBoundary,subjectLineSegment);
            end
            
            clippedPolygon(end+1,1:2) = inputList(subjectVertex,:);
            
        elseif( inside(previousVertex,clipBoundary) )
            subjectLineSegment = [previousVertex;inputList(subjectVertex,:)];
            clippedPolygon(end+1,1:2) = computeIntersection(clipBoundary,subjectLineSegment);
        end
        
        previousVertex = inputList(subjectVertex,:);
        clipVertexPrevious = clipPolygon(clipVertex,:);
        
    end %for subject verticies
end %for boundary verticies
end %sutherlandHodgman
function F=circ_gauss(X,Y,Sigma,center)
%--------------------------------------------------------------------------
% circ_gauss function                                                General
% Description: Calculate 2D circular Gaussian in a 2-D grid.
% Input  : - Scalar, vector or matrix of X-coordinates in which to calculate
%            the 2-D Gaussian.
%          - same as the x-ccordinates, but for the y-axis.
%          - Sigma of the Gaussian or [SigmaX, SigmaY] in case sigma
%            is different for each axis.
%            By default SigmaY=SigmaX.
%            If empty matrix use default.Si
%          - Center of the Gaussian [X, Y].
%            By default Y=X.
%            Default is [0 0].
%            If empty matrix use default.
%          - Maximum radius of Gaussian behond to set it to zero.
%            Default is Inf.
%            MaxRad is measured from the center of the kernel and not
%            the center of the Gaussian.


% Example:
%          F=circ_gauss(MatX,MatY,[1],[0 0]);
%          surface(F);
%--------------------------------------------------------------------------



SigmaX = Sigma(1);
SigmaY = Sigma(2);

X0 = center(1);
Y0 = center(2);

F = 1./(2.*pi.*SigmaX.*SigmaY) .*exp(-1./(2.).* ((X-X0).^2./SigmaX.^2 +(Y-Y0).^2./SigmaY.^2));

F = F./sum(sum(F));

% set elements outside MaxRad to zero:
% if (~isinf(cutoff)),
%    MatR = sqrt(X.^2 + Y.^2);
%    I = find(MatR>cutoff);
%    F(I) = 0;
% end
%
% if (isnan(Norm)),
%    % do not normalize
% else
%    F = Norm.*F./sumnd(F);
% end
end


